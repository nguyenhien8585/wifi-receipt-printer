<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>In Phi·∫øu Thu Ti·ªÅn WiFi 58mm - Bluetooth (Fixed Ti·∫øng Vi·ªát)</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#e74c3c">
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 10px;
      color: #333;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.15);
      overflow: hidden;
    }
    
    .header {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      color: white;
      text-align: center;
      padding: 20px;
      position: relative;
    }
    
    .header h1 {
      font-size: 24px;
      margin: 0;
    }
    
    .header .subtitle {
      font-size: 14px;
      opacity: 0.9;
      margin-top: 5px;
    }
    
    .bluetooth-status {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 12px;
      padding: 5px 10px;
      border-radius: 12px;
      background: rgba(255,255,255,0.2);
      transition: all 0.3s;
    }
    
    .bluetooth-status.connected {
      background: #27ae60;
    }
    
    .config-section {
      background: #f8f9fa;
      padding: 20px;
      border-bottom: 1px solid #dee2e6;
    }
    
    .config-section h3 {
      color: #495057;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .config-row {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .config-row label {
      min-width: 120px;
      font-weight: 600;
      color: #495057;
    }
    
    .config-row input, .config-row select {
      flex: 1;
      padding: 10px 15px;
      border: 2px solid #ced4da;
      border-radius: 8px;
      font-size: 14px;
      min-width: 250px;
      transition: all 0.3s;
    }
    
    .config-row input:focus, .config-row select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    
    .controls {
      padding: 20px;
      background: #f8f9fa;
      border-bottom: 1px solid #dee2e6;
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .search-group {
      flex: 1;
      min-width: 300px;
      display: flex;
      gap: 10px;
    }
    
    #searchInput {
      flex: 1;
      padding: 12px 16px;
      border: 2px solid #ddd;
      border-radius: 25px;
      font-size: 16px;
      outline: none;
      transition: all 0.3s;
    }
    
    #searchInput:focus {
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    
    .btn {
      padding: 12px 20px;
      border: none;
      border-radius: 25px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      white-space: nowrap;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }
    
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    
    .btn-primary { background: linear-gradient(135deg, #3498db, #2980b9); color: white; }
    .btn-success { background: linear-gradient(135deg, #27ae60, #229954); color: white; }
    .btn-warning { background: linear-gradient(135deg, #f39c12, #e67e22); color: white; }
    .btn-danger { background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; }
    .btn-info { background: linear-gradient(135deg, #17a2b8, #138496); color: white; }
    
    .status {
      text-align: center;
      padding: 30px 20px;
      font-size: 16px;
      color: #666;
    }
    
    .status.loading {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
    }
    
    .status.loading::before {
      content: '';
      width: 24px;
      height: 24px;
      border: 3px solid #ddd;
      border-top: 3px solid #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    .status.success {
      color: #27ae60;
    }
    
    .status.error {
      color: #e74c3c;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .error {
      background: #f8d7da;
      color: #721c24;
      padding: 15px 20px;
      margin: 20px;
      border-radius: 8px;
      border-left: 4px solid #dc3545;
    }
    
    .records {
      max-height: calc(100vh - 450px);
      overflow-y: auto;
    }
    
    .record {
      border-bottom: 1px solid #eee;
      padding: 20px;
      transition: all 0.3s;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 20px;
    }
    
    .record:hover {
      background: #f8f9fa;
    }
    
    .record:last-child {
      border-bottom: none;
    }
    
    .record.printed {
      background: linear-gradient(90deg, #d4edda 0%, #ffffff 100%);
      border-left: 4px solid #27ae60;
    }
    
    .record-info {
      flex: 1;
    }
    
    .record-name {
      font-size: 18px;
      font-weight: 600;
      color: #2c3e50;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .record-details {
      color: #666;
      line-height: 1.8;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 8px;
    }
    
    .record-details div {
      display: flex;
      align-items: flex-start;
    }
    
    .record-details strong {
      min-width: 100px;
      color: #495057;
    }
    
    .record-actions {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: flex-end;
      min-width: 150px;
    }
    
    .amount {
      font-size: 20px;
      font-weight: 700;
      color: #e74c3c;
      text-align: right;
      background: rgba(231, 76, 60, 0.1);
      padding: 8px 15px;
      border-radius: 20px;
      border: 2px solid rgba(231, 76, 60, 0.2);
    }
    
    .print-status {
      background: linear-gradient(135deg, #27ae60, #229954);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      text-align: center;
      box-shadow: 0 3px 10px rgba(39, 174, 96, 0.3);
    }
    
    .no-bluetooth {
      background: #fff3cd;
      color: #856404;
      padding: 15px 20px;
      margin: 20px;
      border-radius: 8px;
      border: 1px solid #ffeaa7;
      text-align: center;
    }
    
    .footer {
      background: #2c3e50;
      color: white;
      text-align: center;
      padding: 20px;
      font-size: 14px;
    }
    
    .encoding-info {
      background: #e7f5ff;
      border: 1px solid #339af0;
      border-radius: 8px;
      padding: 10px;
      margin-top: 10px;
      font-size: 12px;
      color: #1864ab;
    }
    
    @media (max-width: 768px) {
      body {
        padding: 5px;
      }
      
      .header h1 {
        font-size: 20px;
      }
      
      .bluetooth-status {
        position: static;
        display: block;
        margin-top: 10px;
        text-align: center;
      }
      
      .config-row {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .config-row label {
        min-width: auto;
      }
      
      .config-row input, .config-row select {
        width: 100%;
        min-width: auto;
      }
      
      .controls {
        flex-direction: column;
        align-items: stretch;
      }
      
      .search-group {
        width: 100%;
        min-width: auto;
        flex-direction: column;
      }
      
      .btn {
        width: 100%;
        justify-content: center;
      }
      
      .record {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .record-actions {
        width: 100%;
        align-items: center;
      }
      
      .record-details {
        grid-template-columns: 1fr;
      }
      
      .amount {
        font-size: 18px;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <div style="display: flex; align-items: center; justify-content: center; gap: 15px; margin-bottom: 10px;">
        <img src="https://upload.wikimedia.org/wikipedia/commons/6/63/Logo_Viettel_from_7_January_2021_Slogan.svg" 
             alt="Viettel Logo" 
             style="height: 40px; filter: brightness(0) invert(1);">
        <div>
          <h1 style="margin: 0; font-size: 24px;">In Phi·∫øu Thu Viettel - Text-to-Image</h1>
          <div class="subtitle">üñºÔ∏è Chuy·ªÉn text th√†nh ·∫£nh r·ªìi in - 100% ti·∫øng Vi·ªát c√≥ d·∫•u!</div>
        </div>
      </div>
      <div class="bluetooth-status" id="bluetoothStatus">üî¥ Bluetooth ch∆∞a k·∫øt n·ªëi</div>
    </div>
    
    <!-- C·∫•u h√¨nh k·∫øt n·ªëi -->
    <div class="config-section">
      <h3>‚öôÔ∏è C·∫•u h√¨nh k·∫øt n·ªëi Google Sheets</h3>
      <div class="config-row">
        <label>üìä Sheet ID:</label>
        <input type="text" id="sheetId" value="1JDh0RBSY6rSME3lHmyJhKc5kHw4YD_0f-OFmkkC76Ms" placeholder="Nh·∫≠p ID Google Sheets">
      </div>
      <div class="config-row">
        <label>üìÑ Sheet Name:</label>
        <input type="text" id="sheetName" value="Sheet1" placeholder="T√™n sheet (VD: Sheet1)">
      </div>
      <div class="config-row">
        <label>üî§ Encoding Mode:</label>
        <select id="encodingMode">
          <option value="image-render">üñºÔ∏è Text-to-Image Render (100% NO Chinese!) - Recommended</option>
          <option value="ascii-fallback">ASCII Safe (No Diacritics)</option>
          <option value="tcvn3-abc">TCVN-3 (ABC) - Classic Vietnamese</option>
          <option value="vni-encoding">VNI Encoding - Alternative Vietnamese</option>
          <option value="iso-8859-1">ISO-8859-1 with Custom Mapping</option>
          <option value="composite-chars">Composite Characters (Base + Diacritics)</option>
          <option value="vietnamese-safe">Vietnamese UTF-8 (May cause issues)</option>
          <option value="windows-1258">Windows-1258 (CP1258)</option>
        </select>
      </div>
      <div class="config-row">
        <label></label>
        <div class="encoding-info">
          <strong>üñºÔ∏è Text-to-Image Render:</strong> Chuy·ªÉn text th√†nh ·∫£nh r·ªìi in - 100% kh√¥ng l·ªói Trung Qu·ªëc!<br>
          <strong>ASCII Safe:</strong> B·ªè d·∫•u ti·∫øng Vi·ªát, t∆∞∆°ng th√≠ch 100% (nh∆∞ ·∫£nh th·ª±c t·∫ø)<br>
          <strong>TCVN-3 (ABC):</strong> Encoding ti·∫øng Vi·ªát c·ªï ƒëi·ªÉn, t∆∞∆°ng th√≠ch t·ªët v·ªõi m√°y in c≈©<br>
          <strong>VNI Encoding:</strong> Ph∆∞∆°ng ph√°p m√£ h√≥a ti·∫øng Vi·ªát kh√°c, c√≥ th·ªÉ ho·∫°t ƒë·ªông t·ªët<br>
          <strong>ISO-8859-1:</strong> Latin-1 v·ªõi mapping t√πy ch·ªânh cho ti·∫øng Vi·ªát<br>
          <strong>Composite Characters:</strong> T√°ch ch·ªØ c√°i v√† d·∫•u ri√™ng bi·ªát<br>
          <strong>Vietnamese UTF-8:</strong> Gi·ªØ nguy√™n c√≥ d·∫•u (c√≥ th·ªÉ g√¢y l·ªói)<br>
          <strong>Windows-1258:</strong> Encoding Windows chu·∫©n
        </div>
      </div>
      <div class="config-row">
        <label></label>
        <small style="color: #666; font-style: italic;">
          üí° L·∫•y Sheet ID t·ª´ URL: https://docs.google.com/spreadsheets/d/<strong>SHEET_ID</strong>/edit
        </small>
      </div>
    </div>
    
    <!-- ƒêi·ªÅu khi·ªÉn -->
    <div class="controls">
      <div class="search-group">
        <input type="text" id="searchInput" placeholder="üîç T√¨m ki·∫øm theo t√™n, SƒêT, ƒë·ªãa ch·ªâ...">
        <button class="btn btn-primary" onclick="search()">
          <span>üîç</span> T√¨m ki·∫øm
        </button>
        <button class="btn btn-success" onclick="loadAll()">
          <span>üìã</span> T·∫•t c·∫£
        </button>
      </div>
      
      <button class="btn btn-info" onclick="connectBluetooth()" id="bluetoothBtn">
        <span>üì∂</span> K·∫øt n·ªëi BT
      </button>
      <button class="btn btn-warning" onclick="testConnection()">
        <span>üîß</span> Test Sheet
      </button>
      <button class="btn btn-primary" onclick="testVietnamesePrint()">
        <span>üß™</span> Test + Preview
      </button>
    </div>

    <!-- Tr·∫°ng th√°i -->
    <div id="status" class="status">
      üñºÔ∏è <strong>TEXT-TO-IMAGE MODE - Tri·ªát ƒë·ªÉ kh√¥ng l·ªói k√Ω t·ª± Trung Qu·ªëc!</strong><br>
      1. Ch·ªçn "Text-to-Image Render" (Recommended) - chuy·ªÉn text th√†nh ·∫£nh r·ªìi in<br>
      2. Ho·∫∑c th·ª≠ c√°c encoding kh√°c: TCVN-3, VNI, ISO-8859-1, Composite<br>
      3. K·∫øt n·ªëi Bluetooth Y58<br>
      4. Nh·∫•n "Test In M·∫´u" ƒë·ªÉ xem preview canvas + in th·ª≠<br>
      üí° <strong>Image Mode = 100% ti·∫øng Vi·ªát c√≥ d·∫•u ƒë·∫πp, kh√¥ng bao gi·ªù l·ªói!</strong>
    </div>
    
    <!-- L·ªói -->
    <div id="error" class="error" style="display:none;"></div>
    
    <!-- C·∫£nh b√°o kh√¥ng h·ªó tr·ª£ Bluetooth -->
    <div id="noBluetoothWarning" class="no-bluetooth" style="display:none;">
      ‚ö†Ô∏è <strong>Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Web Bluetooth!</strong><br>
      H√£y s·ª≠ d·ª•ng: <strong>Chrome tr√™n Android</strong> ho·∫∑c <strong>Edge tr√™n Windows</strong>
    </div>
    
    <!-- Danh s√°ch b·∫£n ghi -->
    <div id="records" class="records"></div>
    
    <!-- Footer -->
    <div class="footer">
      <div>üìû Hotline: 0978887797 | üìß Email: support@viettel.com.vn</div>
      <div style="margin-top: 5px; font-size: 12px; opacity: 0.8;">
        ¬© 2024 Viettel ƒê·ªìng Th√°p - üñºÔ∏è Text-to-Image Technology: 100% ti·∫øng Vi·ªát c√≥ d·∫•u, kh√¥ng bao gi·ªù l·ªói!
      </div>
    </div>
  </div>

  <script>
    let allRecords = [];
    let bluetoothDevice = null;
    let bluetoothCharacteristic = null;

    // ==================== KH·ªûI T·∫†O ====================
    
    document.addEventListener('DOMContentLoaded', function() {
      if (!navigator.bluetooth) {
        document.getElementById('noBluetoothWarning').style.display = 'block';
        document.getElementById('bluetoothBtn').disabled = true;
      }
      
      document.getElementById('searchInput').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') search();
      });
      
      // L∆∞u c·∫•u h√¨nh
      ['sheetId', 'sheetName', 'encodingMode'].forEach(id => {
        const input = document.getElementById(id);
        input.value = localStorage.getItem(id) || input.value;
        input.addEventListener('change', () => {
          localStorage.setItem(id, input.value);
        });
      });
    });

    // ==================== BLUETOOTH Y58 - FIXED VIETNAMESE ====================
    
    async function connectBluetooth() {
      if (!navigator.bluetooth) {
        alert('‚ùå Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Bluetooth!\n\n‚úÖ H√£y s·ª≠ d·ª•ng:\n‚Ä¢ Chrome tr√™n Android\n‚Ä¢ Edge tr√™n Windows');
        return;
      }

      try {
        if (bluetoothDevice && bluetoothDevice.gatt.connected) {
          bluetoothDevice.gatt.disconnect();
          updateBluetoothStatus(false);
          return;
        }

        showStatus('loading', 'üîç T√¨m m√°y in Y58...');
        
        bluetoothDevice = await navigator.bluetooth.requestDevice({
          acceptAllDevices: true,
          optionalServices: [
            '000018f0-0000-1000-8000-00805f9b34fb',
            '0000ff00-0000-1000-8000-00805f9b34fb',
            '00001101-0000-1000-8000-00805f9b34fb',
            '0000180f-0000-1000-8000-00805f9b34fb'
          ]
        });

        showStatus('loading', `üì∂ K·∫øt n·ªëi ${bluetoothDevice.name || 'Y58'}...`);

        const server = await bluetoothDevice.gatt.connect();
        const services = await server.getPrimaryServices();
        let foundCharacteristic = null;
        
        for (const service of services) {
          try {
            const characteristics = await service.getCharacteristics();
            foundCharacteristic = characteristics.find(c => 
              c.properties.write || c.properties.writeWithoutResponse
            );
            if (foundCharacteristic) break;
          } catch (e) {
            continue;
          }
        }

        if (!foundCharacteristic) {
          throw new Error('Kh√¥ng t√¨m th·∫•y characteristic ƒë·ªÉ in');
        }

        bluetoothCharacteristic = foundCharacteristic;
        
        bluetoothDevice.addEventListener('gattserverdisconnected', () => {
          updateBluetoothStatus(false);
          showStatus('error', 'üì∂ M√°y in ƒë√£ ng·∫Øt k·∫øt n·ªëi');
        });
        
        updateBluetoothStatus(true, bluetoothDevice.name || 'Y58');
        showStatus('success', `‚úÖ ƒê√£ k·∫øt n·ªëi ${bluetoothDevice.name || 'Y58'}!`);

      } catch (error) {
        console.error('Bluetooth error:', error);
        showError(`‚ùå L·ªói k·∫øt n·ªëi: ${error.message || 'Kh√¥ng th·ªÉ k·∫øt n·ªëi Y58'}`);
        updateBluetoothStatus(false);
      }
    }

    // Test print ti·∫øng Vi·ªát
    async function testVietnamesePrint() {
      if (!bluetoothCharacteristic) {
        alert('‚ùå Ch∆∞a k·∫øt n·ªëi m√°y in Y58!');
        return;
      }

      const encodingMode = document.getElementById('encodingMode').value;
      
      try {
        showStatus('loading', 'üß™ ƒêang test in ti·∫øng Vi·ªát...');
        
        let testContent = '';
        
        if (encodingMode === 'image-render') {
          // Image mode - gi·ªØ nguy√™n ti·∫øng Vi·ªát c√≥ d·∫•u ƒë·∫πp
          testContent = 
            'T√™n kh√°ch h√†ng:\n' +
            'NGUY·ªÑN B·∫¢O CH√ç\n' +
            'ƒê·ªãa ch·ªâ: Ph√∫ L·ª£i A Ph√∫\n' +
            'Thu·∫≠n B H·ªìng Ng·ª±\n' +
            'ƒê·ªìng Th√°p.\n' +
            'S·ªë ti·ªÅn: 200.000 ƒë\n' +
            'B·∫±ng ch·ªØ: Hai trƒÉm ngh√¨n ƒë·ªìng.\n' +
            'Test all diacritics:\n' +
            '√† √° ·∫£ √£ ·∫° ƒÉ ·∫± ·∫Ø ·∫≥ ·∫µ ·∫∑\n' +
            '√¢ ·∫ß ·∫• ·∫© ·∫´ ·∫≠ √® √© ·∫ª ·∫Ω ·∫π\n' +
            '√™ ·ªÅ ·∫ø ·ªÉ ·ªÖ ·ªá √≤ √≥ ·ªè √µ ·ªç\n' +
            '√¥ ·ªì ·ªë ·ªï ·ªó ·ªô ∆° ·ªù ·ªõ ·ªü ·ª° ·ª£\n' +
            '√π √∫ ·ªß ≈© ·ª• ∆∞ ·ª´ ·ª© ·ª≠ ·ªØ ·ª±\n' +
            '·ª≥ √Ω ·ª∑ ·ªπ ·ªµ ƒë ƒê √Ä√Å·∫¢√É·∫†\n';
        } else if (encodingMode === 'ascii-fallback') {
          testContent = 
            'Ten khach hang:\n' +
            'NGUYEN BAO CHI\n' +
            'Dia chi: Phu Loi A Phu\n' +
            'Thuan B Hong Ngu\n' +
            'Dong Thap.\n' +
            'So tien: 200.000 d\n' +
            'Bang chu: Hai tram ngan dong.\n';
        } else {
          testContent = 
            'T√™n kh√°ch h√†ng:\n' +
            'NGUY·ªÑN B·∫¢O CH√ç\n' +
            'ƒê·ªãa ch·ªâ: Ph√∫ L·ª£i A Ph√∫\n' +
            'Thu·∫≠n B H·ªìng Ng·ª±\n' +
            'ƒê·ªìng Th√°p.\n' +
            'S·ªë ti·ªÅn: 200.000 ƒë\n' +
            'B·∫±ng ch·ªØ: Hai trƒÉm ngh√¨n ƒë·ªìng.\n' +
            'Test t·∫•t c·∫£ d·∫•u:\n' +
            '√† √° ·∫£ √£ ·∫° ƒÉ ·∫± ·∫Ø ·∫≥ ·∫µ ·∫∑\n' +
            '√¢ ·∫ß ·∫• ·∫© ·∫´ ·∫≠ √® √© ·∫ª ·∫Ω ·∫π\n' +
            '√™ ·ªÅ ·∫ø ·ªÉ ·ªÖ ·ªá √≤ √≥ ·ªè √µ ·ªç\n' +
            '√¥ ·ªì ·ªë ·ªï ·ªó ·ªô ∆° ·ªù ·ªõ ·ªü ·ª° ·ª£\n' +
            '√π √∫ ·ªß ≈© ·ª• ∆∞ ·ª´ ·ª© ·ª≠ ·ªØ ·ª±\n' +
            '·ª≥ √Ω ·ª∑ ·ªπ ·ªµ ƒë ƒê\n';
        }
        
        const testText = 
          '\n' +
          '     viettel\n' +
          '  Theo c√°ch c·ªßa b·∫°n\n' +
          '\n' +
          ' VIETTEL ƒê·ªíNG TH√ÅP\n' +
          '    TEST ENCODING\n' +
          '================================\n' +
          testContent +
          '================================\n' +
          ` Encoding: ${encodingMode}\n` +
          ` Th·ªùi gian: ${new Date().toLocaleString('vi-VN')}\n` +
          '\n\n';

        await sendToYT58Printer(testText);
        
        if (encodingMode === 'image-render') {
          showStatus('success', '‚úÖ Test image render th√†nh c√¥ng! Ki·ªÉm tra preview canvas v√† m√°y in.');
        } else {
          showStatus('success', `‚úÖ Test encoding ${encodingMode} th√†nh c√¥ng!`);
        }
        
      } catch (error) {
        console.error('Test error:', error);
        showError(`‚ùå L·ªói test: ${error.message}`);
      }
    }

    // ==================== FIXED VIETNAMESE ENCODING FOR Y58 ====================
    
    async function printReceiptBluetooth(receiptData) {
      if (!bluetoothCharacteristic) {
        throw new Error('Ch∆∞a k·∫øt n·ªëi m√°y in');
      }

      const encodingMode = document.getElementById('encodingMode').value;

      try {
        let receipt = '';
        
        // Reset v√† setup m√°y in
        receipt += '\x1B\x40'; // ESC @ - Reset printer
        await sleep(200);
        
        if (encodingMode === 'image-render') {
          // üñºÔ∏è IMAGE MODE - Render th√†nh ·∫£nh r·ªìi in
          receipt += '\n';
          receipt += '     viettel\n';
          receipt += '  Theo c√°ch c·ªßa b·∫°n\n';
          receipt += '\n';
          receipt += ' VIETTEL ƒê·ªíNG TH√ÅP\n';
          receipt += '    BI√äN NH·∫¨N\n';
          receipt += '================================\n';
          receipt += 'T√™n kh√°ch h√†ng:\n';
          receipt += `${receiptData.name}\n`;
          receipt += 'ƒê·ªãa ch·ªâ: ';
          
          const address = receiptData.address;
          if (address.length > 25) {
            const addressLines = wrapText(address, 25);
            receipt += addressLines[0] + '\n';
            for (let i = 1; i < addressLines.length; i++) {
              receipt += addressLines[i] + '\n';
            }
          } else {
            receipt += address + '\n';
          }
          
          receipt += 'Thu√™ bao:\n';
          receipt += `${receiptData.service}\n`;
          receipt += 'N·ªôi dung:\n';
          receipt += `${receiptData.content}\n`;
          receipt += 'ƒêi·ªán tho·∫°i li√™n h·ªá:\n';
          receipt += `${receiptData.phone}\n`;
          receipt += 'K√Ω c∆∞·ªõc:\n';
          receipt += `${formatDateVietnam(new Date())}\n`;
          receipt += `S·ªë ti·ªÅn: ${formatMoneyVietnam(receiptData.amount)}\n`;
          receipt += `B·∫±ng ch·ªØ: ${numberToVietnameseWords(receiptData.amount)}\n`;
          receipt += 'SƒêT li√™n h·ªá: 0978887797\n';
          receipt += 'T·ªïng ƒë√†i CSKH: 18008119\n';
          receipt += '\n\n\n';
          
          // G·ª≠i qua image rendering
          await sendToYT58Printer(receipt);
          return;
        }
        
        // Header v·ªõi logo Viettel (text-based v√¨ m√°y in nhi·ªát)
        receipt += '\x1B\x61\x01'; // Center align
        receipt += '\n';
        receipt += '     viettel\n';
        receipt += '  Theo cach cua ban\n';
        receipt += '\n';
        receipt += ' VIETTEL DONG THAP\n';
        receipt += '\x1B\x45\x01'; // Bold ON
        receipt += '    BIEN NHAN\n';
        receipt += '\x1B\x45\x00'; // Bold OFF
        receipt += '\x1B\x61\x00'; // Left align
        receipt += '================================\n';
        
        // Th√¥ng tin kh√°ch h√†ng - Format adaptive theo encoding
        if (encodingMode === 'ascii-fallback') {
          receipt += 'Ten khach hang:\n';
          receipt += `${receiptData.name}\n`;
          receipt += 'Dia chi: ';
          
          const address = receiptData.address;
          if (address.length > 25) {
            const addressLines = wrapText(address, 25);
            receipt += addressLines[0] + '\n';
            for (let i = 1; i < addressLines.length; i++) {
              receipt += addressLines[i] + '\n';
            }
          } else {
            receipt += address + '\n';
          }
          
          receipt += 'Thue bao:\n';
          receipt += `${receiptData.service}\n`;
          receipt += 'Noi dung:\n';
          receipt += `${receiptData.content}\n`;
          receipt += 'Dien thoai lien he:\n';
          receipt += `${receiptData.phone}\n`;
          receipt += 'Ky cuoc:\n';
        } else {
          receipt += 'T√™n kh√°ch h√†ng:\n';
          receipt += `${receiptData.name}\n`;
          receipt += 'ƒê·ªãa ch·ªâ: ';
          
          const address = receiptData.address;
          if (address.length > 25) {
            const addressLines = wrapText(address, 25);
            receipt += addressLines[0] + '\n';
            for (let i = 1; i < addressLines.length; i++) {
              receipt += addressLines[i] + '\n';
            }
          } else {
            receipt += address + '\n';
          }
          
          receipt += 'Thu√™ bao:\n';
          receipt += `${receiptData.service}\n`;
          receipt += 'N·ªôi dung:\n';
          receipt += `${receiptData.content}\n`;
          receipt += 'ƒêi·ªán tho·∫°i li√™n h·ªá:\n';
          receipt += `${receiptData.phone}\n`;
          receipt += 'K√Ω c∆∞·ªõc:\n';
        }
        
        receipt += `${formatDateVietnam(new Date())}\n`;
        
        // S·ªë ti·ªÅn - Format adaptive
        if (encodingMode === 'ascii-fallback') {
          receipt += `So tien: ${formatMoneyVietnam(receiptData.amount)}\n`;
          receipt += `Bang chu: ${numberToVietnameseWords(receiptData.amount)}\n`;
          receipt += 'SDT lien he: 0978887797\n';
          receipt += 'Tong dai cskh: 18008119\n';
        } else {
          receipt += `S·ªë ti·ªÅn: ${formatMoneyVietnam(receiptData.amount)}\n`;
          receipt += `B·∫±ng ch·ªØ: ${numberToVietnameseWords(receiptData.amount)}\n`;
          receipt += 'SƒêT li√™n h·ªá: 0978887797\n';
          receipt += 'T·ªïng ƒë√†i CSKH: 18008119\n';
        }
        
        receipt += '\n\n\n';

        await sendToYT58Printer(receipt);

      } catch (error) {
        throw new Error(`L·ªói in: ${error.message}`);
      }
    }

    // Send data to Y58 printer v·ªõi multiple encoding options + IMAGE RENDERING
    async function sendToYT58Printer(text) {
      if (!bluetoothCharacteristic) {
        throw new Error('Ch∆∞a k·∫øt n·ªëi Y58');
      }

      const encodingMode = document.getElementById('encodingMode').value;
      
      try {
        if (encodingMode === 'image-render') {
          // üñºÔ∏è TEXT-TO-IMAGE MODE - Tri·ªát ƒë·ªÉ kh√¥ng l·ªói k√Ω t·ª± Trung Qu·ªëc
          console.log('üñºÔ∏è Rendering text to image...');
          await printTextAsImage(text);
          return;
        }
        
        // Setup printer v·ªõi ESC commands cho text modes
        let setupCommands = '';
        setupCommands += '\x1B\x40'; // ESC @ - Reset printer
        
        // Ch·ªçn code page t√πy theo encoding mode
        switch (encodingMode) {
          case 'tcvn3-abc':
          case 'vni-encoding':
          case 'iso-8859-1':
            setupCommands += '\x1B\x74\x00'; // ESC t 0 - PC437 (US)
            break;
          case 'composite-chars':
            setupCommands += '\x1B\x74\x01'; // ESC t 1 - Katakana
            break;
          case 'windows-1258':
            setupCommands += '\x1B\x74\x1E'; // ESC t 30 - CP1258
            break;
          default:
            setupCommands += '\x1B\x74\x1E'; // ESC t 30 - CP1258 default
        }
        
        setupCommands += '\x1B\x52\x08'; // ESC R 8 - Select international character set
        
        // G·ª≠i setup commands tr∆∞·ªõc
        await sendRawBytes(textToBytes(setupCommands));
        await sleep(200);
        
        let processedText;
        
        switch (encodingMode) {
          case 'ascii-fallback':
            processedText = removeDiacritics(text);
            break;
          case 'tcvn3-abc':
            processedText = convertToTCVN3(text);
            break;
          case 'vni-encoding':
            processedText = convertToVNI(text);
            break;
          case 'iso-8859-1':
            processedText = convertToISO88591(text);
            break;
          case 'composite-chars':
            processedText = convertToCompositeChars(text);
            break;
          case 'vietnamese-safe':
            processedText = convertToVietnameseSafe(text);
            break;
          case 'windows-1258':
            processedText = convertToWindows1258(text);
            break;
          default:
            processedText = removeDiacritics(text);
        }
        
        console.log('Encoding mode:', encodingMode);
        console.log('Original text sample:', text.substring(200, 300));
        console.log('Processed text sample:', processedText.substring(200, 300));
        
        // G·ª≠i processed text
        const bytes = textToBytes(processedText);
        await sendRawBytes(bytes);
        
      } catch (error) {
        console.error('Send error:', error);
        throw new Error('L·ªói g·ª≠i d·ªØ li·ªáu ƒë·∫øn m√°y in');
      }
    }

    // üñºÔ∏è TEXT-TO-IMAGE RENDERING - Tri·ªát ƒë·ªÉ kh√¥ng l·ªói k√Ω t·ª± Trung Qu·ªëc
    async function printTextAsImage(text) {
      try {
        console.log('üìù Creating canvas for text rendering...');
        
        // T·∫°o canvas ƒë·ªÉ render text
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // K√≠ch th∆∞·ªõc cho m√°y in 58mm (384 pixels width)
        const printWidth = 384;
        canvas.width = printWidth;
        
        // Setup font cho ti·∫øng Vi·ªát ƒë·∫πp
        ctx.font = '16px Arial, "Times New Roman", serif';
        ctx.fillStyle = '#000000';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        
        // T√≠nh chi·ªÅu cao c·∫ßn thi·∫øt
        const lines = text.split('\n');
        const lineHeight = 20;
        const padding = 10;
        canvas.height = (lines.length * lineHeight) + (padding * 2);
        
        // Clear canvas v·ªõi m√†u tr·∫Øng
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Render text l√™n canvas
        ctx.fillStyle = '#000000';
        ctx.font = '16px Arial, "Times New Roman", serif';
        
        let y = padding;
        for (const line of lines) {
          if (line.trim()) {
            // Ki·ªÉm tra n·∫øu d√≤ng c·∫ßn center (header)
            if (line.includes('viettel') || line.includes('VIETTEL') || line.includes('BIEN NHAN')) {
              ctx.textAlign = 'center';
              if (line.includes('BIEN NHAN')) {
                ctx.font = 'bold 18px Arial';
              } else {
                ctx.font = '16px Arial';
              }
              ctx.fillText(line.trim(), printWidth / 2, y);
            } else {
              ctx.textAlign = 'left';
              ctx.font = '14px Arial';
              ctx.fillText(line, padding, y);
            }
          }
          y += lineHeight;
        }
        
        console.log('üñºÔ∏è Canvas created, size:', canvas.width, 'x', canvas.height);
        
        // Show preview (optional - for debugging)
        showCanvasPreview(canvas);
        
        // Convert canvas to monochrome bitmap
        const bitmapData = canvasToMonochromeBitmap(canvas);
        
        // Convert bitmap to ESC/POS commands
        const escPosCommands = bitmapToESCPOS(bitmapData, canvas.width, canvas.height);
        
        console.log('üì° Sending', escPosCommands.length, 'bytes of image data...');
        
        // Send ESC/POS bitmap commands
        await sendRawBytes(escPosCommands);
        
        console.log('‚úÖ Image sent successfully!');
        
      } catch (error) {
        console.error('‚ùå Image rendering error:', error);
        throw new Error('L·ªói render ·∫£nh: ' + error.message);
      }
    }

    // Convert canvas to monochrome bitmap
    function canvasToMonochromeBitmap(canvas) {
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const pixels = imageData.data;
      
      const bitmap = [];
      
      for (let y = 0; y < canvas.height; y++) {
        const row = [];
        for (let x = 0; x < canvas.width; x++) {
          const i = (y * canvas.width + x) * 4;
          const r = pixels[i];
          const g = pixels[i + 1];
          const b = pixels[i + 2];
          
          // Convert to grayscale
          const gray = (r + g + b) / 3;
          
          // Threshold to black/white (1 = black, 0 = white)
          const bit = gray < 128 ? 1 : 0;
          row.push(bit);
        }
        bitmap.push(row);
      }
      
      return bitmap;
    }

    // Convert bitmap to ESC/POS commands
    function bitmapToESCPOS(bitmap, width, height) {
      const commands = [];
      
      // Reset printer
      commands.push(0x1B, 0x40); // ESC @
      
      // Set line spacing to 0
      commands.push(0x1B, 0x33, 0x00); // ESC 3 0
      
      // Process bitmap in 8-pixel high bands
      for (let y = 0; y < height; y += 8) {
        // ESC * m nL nH - Print raster bitmap
        commands.push(0x1B, 0x2A, 0x00); // ESC * 0 (single density)
        
        // Width bytes (little endian)
        const widthBytes = Math.ceil(width / 8);
        commands.push(widthBytes & 0xFF, (widthBytes >> 8) & 0xFF);
        
        // Generate bitmap data for this band
        for (let x = 0; x < width; x += 8) {
          let byte = 0;
          
          for (let bit = 0; bit < 8; bit++) {
            const px = x + bit;
            if (px < width && y < height && bitmap[y] && bitmap[y][px]) {
              byte |= (1 << (7 - bit));
            }
          }
          
          commands.push(byte);
        }
        
        // Line feed
        commands.push(0x0A);
      }
      
      // Restore line spacing
      commands.push(0x1B, 0x32); // ESC 2
      
      // Feed paper
      commands.push(0x0A, 0x0A, 0x0A);
      
      return new Uint8Array(commands);
    }

    // Show canvas preview (for debugging)
    function showCanvasPreview(canvas) {
      // T·∫°o preview container n·∫øu ch∆∞a c√≥
      let previewContainer = document.getElementById('canvasPreview');
      if (!previewContainer) {
        previewContainer = document.createElement('div');
        previewContainer.id = 'canvasPreview';
        previewContainer.style.cssText = `
          position: fixed;
          top: 10px;
          right: 10px;
          background: white;
          border: 2px solid #ccc;
          border-radius: 8px;
          padding: 10px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.2);
          z-index: 1000;
          max-width: 300px;
        `;
        document.body.appendChild(previewContainer);
      }
      
      // Clone canvas ƒë·ªÉ preview
      const previewCanvas = canvas.cloneNode(true);
      const ctx = previewCanvas.getContext('2d');
      ctx.drawImage(canvas, 0, 0);
      
      // Scale down ƒë·ªÉ fit preview
      const scale = Math.min(280 / canvas.width, 400 / canvas.height);
      previewCanvas.style.width = (canvas.width * scale) + 'px';
      previewCanvas.style.height = (canvas.height * scale) + 'px';
      previewCanvas.style.border = '1px solid #ddd';
      
      previewContainer.innerHTML = `
        <div style="font-weight: bold; margin-bottom: 8px; color: #333;">
          üñºÔ∏è Preview (${canvas.width}x${canvas.height}px)
        </div>
      `;
      previewContainer.appendChild(previewCanvas);
      
      // Auto hide sau 5 gi√¢y
      setTimeout(() => {
        if (previewContainer && previewContainer.parentNode) {
          previewContainer.remove();
        }
      }, 5000);
    }

    // Send raw bytes v·ªõi chunk control
    async function sendRawBytes(bytes) {
      const chunkSize = 20;
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        
        if (bluetoothCharacteristic.properties.writeWithoutResponse) {
          await bluetoothCharacteristic.writeValueWithoutResponse(chunk);
        } else {
          await bluetoothCharacteristic.writeValue(chunk);
        }
        
        await sleep(50); // Delay gi·ªØa c√°c chunk
      }
    }

    // VIETNAMESE SAFE ENCODING - Gi·ªØ nguy√™n d·∫•u ti·∫øng Vi·ªát
    function convertToVietnameseSafe(text) {
      // B·∫£ng CP1258 ch√≠nh x√°c cho m√°y in Y58 - GI·ªÆ NGUY√äN TI·∫æNG VI·ªÜT C√ì D·∫§U
      const cp1258Map = {
        // Ch·ªØ th∆∞·ªùng c√≥ d·∫•u - mapped to safe bytes
        '√†': 0xE0, '√°': 0xE1, '·∫£': 0x83, '√£': 0x84, '·∫°': 0x85,
        'ƒÉ': 0x86, '·∫±': 0x87, '·∫Ø': 0x88, '·∫≥': 0x89, '·∫µ': 0x8A, '·∫∑': 0x8B,
        '√¢': 0xE2, '·∫ß': 0x8C, '·∫•': 0x8D, '·∫©': 0x8E, '·∫´': 0x8F, '·∫≠': 0x90,
        
        '√®': 0xE8, '√©': 0xE9, '·∫ª': 0x91, '·∫Ω': 0x92, '·∫π': 0x93,
        '√™': 0xEA, '·ªÅ': 0x94, '·∫ø': 0x95, '·ªÉ': 0x96, '·ªÖ': 0x97, '·ªá': 0x98,
        
        '√¨': 0xEC, '√≠': 0xED, '·ªâ': 0x99, 'ƒ©': 0x9A, '·ªã': 0x9B,
        
        '√≤': 0xF2, '√≥': 0xF3, '·ªè': 0x9C, '√µ': 0xF5, '·ªç': 0x9D,
        '√¥': 0xF4, '·ªì': 0x9E, '·ªë': 0x9F, '·ªï': 0xA0, '·ªó': 0xA1, '·ªô': 0xA2,
        '∆°': 0xA3, '·ªù': 0xA4, '·ªõ': 0xA5, '·ªü': 0xA6, '·ª°': 0xA7, '·ª£': 0xA8,
        
        '√π': 0xF9, '√∫': 0xFA, '·ªß': 0xA9, '≈©': 0xAA, '·ª•': 0xAB,
        '∆∞': 0xAC, '·ª´': 0xAD, '·ª©': 0xAE, '·ª≠': 0xAF, '·ªØ': 0xB0, '·ª±': 0xB1,
        
        '·ª≥': 0xB2, '√Ω': 0xFD, '·ª∑': 0xB3, '·ªπ': 0xB4, '·ªµ': 0xB5,
        
        'ƒë': 0xF0,
        
        // Ch·ªØ hoa c√≥ d·∫•u
        '√Ä': 0xC0, '√Å': 0xC1, '·∫¢': 0xC3, '√É': 0xC4, '·∫†': 0xC5,
        'ƒÇ': 0xC6, '·∫∞': 0xC7, '·∫Æ': 0xC8, '·∫≤': 0xC9, '·∫¥': 0xCA, '·∫∂': 0xCB,
        '√Ç': 0xC2, '·∫¶': 0xCC, '·∫§': 0xCD, '·∫®': 0xCE, '·∫™': 0xCF, '·∫¨': 0xD0,
        
        '√à': 0xC8, '√â': 0xC9, '·∫∫': 0xD1, '·∫º': 0xD2, '·∫∏': 0xD3,
        '√ä': 0xCA, '·ªÄ': 0xD4, '·∫æ': 0xD5, '·ªÇ': 0xD6, '·ªÑ': 0xD7, '·ªÜ': 0xD8,
        
        '√å': 0xCC, '√ç': 0xCD, '·ªà': 0xD9, 'ƒ®': 0xDA, '·ªä': 0xDB,
        
        '√í': 0xD2, '√ì': 0xD3, '·ªé': 0xDC, '√ï': 0xD5, '·ªå': 0xDD,
        '√î': 0xD4, '·ªí': 0xDE, '·ªê': 0xDF, '·ªî': 0xE0, '·ªñ': 0xE1, '·ªò': 0xE2,
        '∆†': 0xE3, '·ªú': 0xE4, '·ªö': 0xE5, '·ªû': 0xE6, '·ª†': 0xE7, '·ª¢': 0xE8,
        
        '√ô': 0xD9, '√ö': 0xDA, '·ª¶': 0xE9, '≈®': 0xEA, '·ª§': 0xEB,
        '∆Ø': 0xEC, '·ª™': 0xED, '·ª®': 0xEE, '·ª¨': 0xEF, '·ªÆ': 0xF0, '·ª∞': 0xF1,
        
        '·ª≤': 0xF2, '√ù': 0xDD, '·ª∂': 0xF3, '·ª∏': 0xF4, '·ª¥': 0xF5,
        
        'ƒê': 0xD0
      };

      // Chuy·ªÉn th√†nh byte array gi·ªØ nguy√™n ti·∫øng Vi·ªát c√≥ d·∫•u
      let result = '';
      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        if (cp1258Map[char]) {
          // K√Ω t·ª± ti·∫øng Vi·ªát - gi·ªØ nguy√™n
          result += char;
        } else {
          // K√Ω t·ª± ASCII th∆∞·ªùng
          result += char;
        }
      }
      
      return result;
    }

    // WINDOWS-1258 ENCODING - Ch√≠nh x√°c cho ti·∫øng Vi·ªát
    function convertToWindows1258(text) {
      // B·∫£ng CP1258 chu·∫©n Windows Vietnamese
      const win1258Map = {
        // Ch·ªØ th∆∞·ªùng c√≥ d·∫•u
        '√†': 0xE0, '√°': 0xE1, '·∫£': 0x1EA3, '√£': 0x1EA5, '·∫°': 0x1EA1,
        'ƒÉ': 0x103, '·∫±': 0x1EB1, '·∫Ø': 0x1EAF, '·∫≥': 0x1EB3, '·∫µ': 0x1EB5, '·∫∑': 0x1EB7,
        '√¢': 0xE2, '·∫ß': 0x1EA7, '·∫•': 0x1EA5, '·∫©': 0x1EA9, '·∫´': 0x1EAB, '·∫≠': 0x1EAD,
        '√®': 0xE8, '√©': 0xE9, '·∫ª': 0x1EBB, '·∫Ω': 0x1EBD, '·∫π': 0x1EB9,
        '√™': 0xEA, '·ªÅ': 0x1EC1, '·∫ø': 0x1EBF, '·ªÉ': 0x1EC3, '·ªÖ': 0x1EC5, '·ªá': 0x1EC7,
        '√¨': 0xEC, '√≠': 0xED, '·ªâ': 0x1EC9, 'ƒ©': 0x129, '·ªã': 0x1ECB,
        '√≤': 0xF2, '√≥': 0xF3, '·ªè': 0x1ECF, '√µ': 0xF5, '·ªç': 0x1ECD,
        '√¥': 0xF4, '·ªì': 0x1ED3, '·ªë': 0x1ED1, '·ªï': 0x1ED5, '·ªó': 0x1ED7, '·ªô': 0x1ED9,
        '∆°': 0x1A1, '·ªù': 0x1EDD, '·ªõ': 0x1EDB, '·ªü': 0x1EDF, '·ª°': 0x1EE1, '·ª£': 0x1EE3,
        '√π': 0xF9, '√∫': 0xFA, '·ªß': 0x1EE7, '≈©': 0x169, '·ª•': 0x1EE5,
        '∆∞': 0x1B0, '·ª´': 0x1EEB, '·ª©': 0x1EE9, '·ª≠': 0x1EED, '·ªØ': 0x1EEF, '·ª±': 0x1EF1,
        '·ª≥': 0x1EF3, '√Ω': 0xFD, '·ª∑': 0x1EF7, '·ªπ': 0x1EF9, '·ªµ': 0x1EF5,
        'ƒë': 0x111,
        
        // Ch·ªØ hoa c√≥ d·∫•u
        '√Ä': 0xC0, '√Å': 0xC1, '·∫¢': 0x1EA2, '√É': 0x1EA4, '·∫†': 0x1EA0,
        'ƒÇ': 0x102, '·∫∞': 0x1EB0, '·∫Æ': 0x1EAE, '·∫≤': 0x1EB2, '·∫¥': 0x1EB4, '·∫∂': 0x1EB6,
        '√Ç': 0xC2, '·∫¶': 0x1EA6, '·∫§': 0x1EA4, '·∫®': 0x1EA8, '·∫™': 0x1EAA, '·∫¨': 0x1EAC,
        '√à': 0xC8, '√â': 0xC9, '·∫∫': 0x1EBA, '·∫º': 0x1EBC, '·∫∏': 0x1EB8,
        '√ä': 0xCA, '·ªÄ': 0x1EC0, '·∫æ': 0x1EBE, '·ªÇ': 0x1EC2, '·ªÑ': 0x1EC4, '·ªÜ': 0x1EC6,
        '√å': 0xCC, '√ç': 0xCD, '·ªà': 0x1EC8, 'ƒ®': 0x128, '·ªä': 0x1ECA,
        '√í': 0xD2, '√ì': 0xD3, '·ªé': 0x1ECE, '√ï': 0xD5, '·ªå': 0x1ECC,
        '√î': 0xD4, '·ªí': 0x1ED2, '·ªê': 0x1ED0, '·ªî': 0x1ED4, '·ªñ': 0x1ED6, '·ªò': 0x1ED8,
        '∆†': 0x1A0, '·ªú': 0x1EDC, '·ªö': 0x1EDA, '·ªû': 0x1EDE, '·ª†': 0x1EE0, '·ª¢': 0x1EE2,
        '√ô': 0xD9, '√ö': 0xDA, '·ª¶': 0x1EE6, '≈®': 0x168, '·ª§': 0x1EE4,
        '∆Ø': 0x1AF, '·ª™': 0x1EEA, '·ª®': 0x1EE8, '·ª¨': 0x1EEC, '·ªÆ': 0x1EEE, '·ª∞': 0x1EF0,
        '·ª≤': 0x1EF2, '√ù': 0xDD, '·ª∂': 0x1EF6, '·ª∏': 0x1EF8, '·ª¥': 0x1EF4,
        'ƒê': 0x110
      };

      let result = '';
      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        if (win1258Map[char]) {
          // Chuy·ªÉn Unicode th√†nh byte t∆∞∆°ng ·ª©ng
          const byte = win1258Map[char];
          if (byte <= 255) {
            result += String.fromCharCode(byte);
          } else {
            // V·ªõi k√Ω t·ª± ph·ª©c t·∫°p, gi·ªØ nguy√™n
            result += char;
          }
        } else {
          result += char;
        }
      }
      
      return result;
    }

    // TCVN-3 (ABC) ENCODING - Classic Vietnamese encoding
    function convertToTCVN3(text) {
      // TCVN-3 mapping cho ti·∫øng Vi·ªát - t∆∞∆°ng th√≠ch m√°y in c≈©
      const tcvn3Map = {
        // Ch·ªØ th∆∞·ªùng c√≥ d·∫•u
        '√†': '\x85', '√°': '\x86', '·∫£': '\x87', '√£': '\x88', '·∫°': '\x89',
        'ƒÉ': '\x8A', '·∫±': '\x8B', '·∫Ø': '\x8C', '·∫≥': '\x8D', '·∫µ': '\x8E', '·∫∑': '\x8F',
        '√¢': '\x90', '·∫ß': '\x91', '·∫•': '\x92', '·∫©': '\x93', '·∫´': '\x94', '·∫≠': '\x95',
        '√®': '\x96', '√©': '\x97', '·∫ª': '\x98', '·∫Ω': '\x99', '·∫π': '\x9A',
        '√™': '\x9B', '·ªÅ': '\x9C', '·∫ø': '\x9D', '·ªÉ': '\x9E', '·ªÖ': '\x9F', '·ªá': '\xA0',
        '√¨': '\xA1', '√≠': '\xA2', '·ªâ': '\xA3', 'ƒ©': '\xA4', '·ªã': '\xA5',
        '√≤': '\xA6', '√≥': '\xA7', '·ªè': '\xA8', '√µ': '\xA9', '·ªç': '\xAA',
        '√¥': '\xAB', '·ªì': '\xAC', '·ªë': '\xAD', '·ªï': '\xAE', '·ªó': '\xAF', '·ªô': '\xB0',
        '∆°': '\xB1', '·ªù': '\xB2', '·ªõ': '\xB3', '·ªü': '\xB4', '·ª°': '\xB5', '·ª£': '\xB6',
        '√π': '\xB7', '√∫': '\xB8', '·ªß': '\xB9', '≈©': '\xBA', '·ª•': '\xBB',
        '∆∞': '\xBC', '·ª´': '\xBD', '·ª©': '\xBE', '·ª≠': '\xBF', '·ªØ': '\xC0', '·ª±': '\xC1',
        '·ª≥': '\xC2', '√Ω': '\xC3', '·ª∑': '\xC4', '·ªπ': '\xC5', '·ªµ': '\xC6',
        'ƒë': '\xC7',
        
        // Ch·ªØ hoa c√≥ d·∫•u - simplified mapping
        '√Ä': '\x80', '√Å': '\x81', '·∫¢': '\x82', '√É': '\x83', '·∫†': '\x84',
        'ƒÇ': '\xC8', '√Ç': '\xC9', '√à': '\xCA', '√â': '\xCB', '·∫∫': '\xCC',
        '√ä': '\xCD', '√å': '\xCE', '√ç': '\xCF', '√í': '\xD0', '√ì': '\xD1',
        '√î': '\xD2', '∆†': '\xD3', '√ô': '\xD4', '√ö': '\xD5', '∆Ø': '\xD6',
        '√ù': '\xD7', 'ƒê': '\xD8'
      };

      let result = '';
      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        if (tcvn3Map[char]) {
          result += tcvn3Map[char];
        } else {
          result += char;
        }
      }
      
      return result;
    }

    // VNI ENCODING - Alternative Vietnamese encoding
    function convertToVNI(text) {
      // VNI mapping cho ti·∫øng Vi·ªát
      const vniMap = {
        // Ch·ªØ th∆∞·ªùng
        '√†': '\xE0', '√°': '\xE1', '·∫£': '\xE2', '√£': '\xE3', '·∫°': '\xE4',
        'ƒÉ': '\xE5', '·∫±': '\xE6', '·∫Ø': '\xE7', '·∫≥': '\xE8', '·∫µ': '\xE9', '·∫∑': '\xEA',
        '√¢': '\xEB', '·∫ß': '\xEC', '·∫•': '\xED', '·∫©': '\xEE', '·∫´': '\xEF', '·∫≠': '\xF0',
        '√®': '\xF1', '√©': '\xF2', '·∫ª': '\xF3', '·∫Ω': '\xF4', '·∫π': '\xF5',
        '√™': '\xF6', '·ªÅ': '\xF7', '·∫ø': '\xF8', '·ªÉ': '\xF9', '·ªÖ': '\xFA', '·ªá': '\xFB',
        '√¨': '\x8C', '√≠': '\x8D', '·ªâ': '\x8E', 'ƒ©': '\x8F', '·ªã': '\x90',
        '√≤': '\x91', '√≥': '\x92', '·ªè': '\x93', '√µ': '\x94', '·ªç': '\x95',
        '√¥': '\x96', '·ªì': '\x97', '·ªë': '\x98', '·ªï': '\x99', '·ªó': '\x9A', '·ªô': '\x9B',
        '∆°': '\x9C', '·ªù': '\x9D', '·ªõ': '\x9E', '·ªü': '\x9F', '·ª°': '\xA0', '·ª£': '\xA1',
        '√π': '\xA2', '√∫': '\xA3', '·ªß': '\xA4', '≈©': '\xA5', '·ª•': '\xA6',
        '∆∞': '\xA7', '·ª´': '\xA8', '·ª©': '\xA9', '·ª≠': '\xAA', '·ªØ': '\xAB', '·ª±': '\xAC',
        '·ª≥': '\xAD', '√Ω': '\xAE', '·ª∑': '\xAF', '·ªπ': '\xB0', '·ªµ': '\xB1',
        'ƒë': '\xB2',
        
        // Ch·ªØ hoa
        '√Ä': '\x80', '√Å': '\x81', '·∫¢': '\x82', '√É': '\x83', '·∫†': '\x84',
        'ƒÇ': '\x85', '√Ç': '\x86', '√à': '\x87', '√â': '\x88', '√ä': '\x89',
        '√å': '\x8A', '√ç': '\x8B', '√í': '\xB3', '√ì': '\xB4', '√î': '\xB5',
        '∆†': '\xB6', '√ô': '\xB7', '√ö': '\xB8', '∆Ø': '\xB9', '√ù': '\xBA',
        'ƒê': '\xBB'
      };

      let result = '';
      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        if (vniMap[char]) {
          result += vniMap[char];
        } else {
          result += char;
        }
      }
      
      return result;
    }

    // ISO-8859-1 with Custom Vietnamese Mapping
    function convertToISO88591(text) {
      // ISO-8859-1 Latin-1 v·ªõi custom mapping cho ti·∫øng Vi·ªát
      const iso88591Map = {
        // Map m·ªôt s·ªë k√Ω t·ª± ti·∫øng Vi·ªát v√†o Latin-1 extended
        '√†': '\xE0', '√°': '\xE1', '√¢': '\xE2', '√£': '\xE3',
        '√®': '\xE8', '√©': '\xE9', '√™': '\xEA',
        '√¨': '\xEC', '√≠': '\xED', '√Æ': '\xEE',
        '√≤': '\xF2', '√≥': '\xF3', '√¥': '\xF4', '√µ': '\xF5',
        '√π': '\xF9', '√∫': '\xFA', '√ª': '\xFB',
        '√Ω': '\xFD',
        '√Ä': '\xC0', '√Å': '\xC1', '√Ç': '\xC2', '√É': '\xC3',
        '√à': '\xC8', '√â': '\xC9', '√ä': '\xCA',
        '√å': '\xCC', '√ç': '\xCD', '√é': '\xCE',
        '√í': '\xD2', '√ì': '\xD3', '√î': '\xD4', '√ï': '\xD5',
        '√ô': '\xD9', '√ö': '\xDA', '√õ': '\xDB',
        '√ù': '\xDD',
        
        // C√°c k√Ω t·ª± ƒë·∫∑c bi·ªát ti·∫øng Vi·ªát fallback v·ªÅ g·∫ßn nh·∫•t
        'ƒÉ': 'a', '·∫Ø': '\xE1', '·∫±': '\xE0', '·∫≥': 'a', '·∫µ': '\xE3', '·∫∑': 'a',
        '·∫≠': '\xE2', '·∫•': '\xE1', '·∫ß': '\xE0', '·∫©': '\xE2', '·∫´': '\xE3',
        '·∫ª': 'e', '·∫Ω': 'e', '·∫π': 'e', '·ªÅ': '\xE8', '·∫ø': '\xE9', '·ªÉ': '\xEA', '·ªÖ': 'e', '·ªá': 'e',
        '·ªâ': 'i', 'ƒ©': 'i', '·ªã': 'i',
        '·ªè': 'o', '·ªç': 'o', '·ªì': '\xF2', '·ªë': '\xF3', '·ªï': '\xF4', '·ªó': '\xF5', '·ªô': 'o',
        '∆°': 'o', '·ªù': '\xF2', '·ªõ': '\xF3', '·ªü': 'o', '·ª°': '\xF5', '·ª£': 'o',
        '·ªß': 'u', '≈©': 'u', '·ª•': 'u',
        '∆∞': 'u', '·ª´': '\xF9', '·ª©': '\xFA', '·ª≠': 'u', '·ªØ': 'u', '·ª±': 'u',
        '·ª≥': 'y', '·ª∑': 'y', '·ªπ': 'y', '·ªµ': 'y',
        'ƒë': 'd', 'ƒê': 'D'
      };

      let result = '';
      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        if (iso88591Map[char]) {
          result += iso88591Map[char];
        } else {
          result += char;
        }
      }
      
      return result;
    }

    // COMPOSITE CHARACTERS - T√°ch ch·ªØ c√°i v√† d·∫•u
    function convertToCompositeChars(text) {
      // T√°ch k√Ω t·ª± c√≥ d·∫•u th√†nh ch·ªØ c√°i + d·∫•u ri√™ng bi·ªát
      const compositeMap = {
        // D·∫•u huy·ªÅn (grave)
        '√†': 'a\x60', '√®': 'e\x60', '√¨': 'i\x60', '√≤': 'o\x60', '√π': 'u\x60', '·ª≥': 'y\x60',
        '√Ä': 'A\x60', '√à': 'E\x60', '√å': 'I\x60', '√í': 'O\x60', '√ô': 'U\x60', '·ª≤': 'Y\x60',
        '·∫ß': 'a\x5E\x60', '·ªÅ': 'e\x5E\x60', '·ªì': 'o\x5E\x60', '·ª´': 'u\x5E\x60',
        '·∫±': 'a\x7E\x60', '·ªù': 'o\x7E\x60',
        
        // D·∫•u s·∫Øc (acute)
        '√°': 'a\x27', '√©': 'e\x27', '√≠': 'i\x27', '√≥': 'o\x27', '√∫': 'u\x27', '√Ω': 'y\x27',
        '√Å': 'A\x27', '√â': 'E\x27', '√ç': 'I\x27', '√ì': 'O\x27', '√ö': 'U\x27', '√ù': 'Y\x27',
        '·∫•': 'a\x5E\x27', '·∫ø': 'e\x5E\x27', '·ªë': 'o\x5E\x27', '·ª©': 'u\x5E\x27',
        '·∫Ø': 'a\x7E\x27', '·ªõ': 'o\x7E\x27',
        
        // D·∫•u ng√£ (tilde)
        '√£': 'a\x7E', '·∫Ω': 'e\x7E', 'ƒ©': 'i\x7E', '√µ': 'o\x7E', '≈©': 'u\x7E', '·ªπ': 'y\x7E',
        '√É': 'A\x7E', '·∫º': 'E\x7E', 'ƒ®': 'I\x7E', '√ï': 'O\x7E', '≈®': 'U\x7E', '·ª∏': 'Y\x7E',
        '·∫´': 'a\x5E\x7E', '·ªÖ': 'e\x5E\x7E', '·ªó': 'o\x5E\x7E', '·ªØ': 'u\x5E\x7E',
        '·∫µ': 'a\x7E\x7E', '·ª°': 'o\x7E\x7E',
        
        // D·∫•u h·ªèi (hook above) - d√πng ?
        '·∫£': 'a\x3F', '·∫ª': 'e\x3F', '·ªâ': 'i\x3F', '·ªè': 'o\x3F', '·ªß': 'u\x3F', '·ª∑': 'y\x3F',
        '·∫©': 'a\x5E\x3F', '·ªÉ': 'e\x5E\x3F', '·ªï': 'o\x5E\x3F', '·ª≠': 'u\x5E\x3F',
        '·∫≥': 'a\x7E\x3F', '·ªü': 'o\x7E\x3F',
        
        // D·∫•u n·∫∑ng (dot below) - d√πng .
        '·∫°': 'a.', '·∫π': 'e.', '·ªã': 'i.', '·ªç': 'o.', '·ª•': 'u.', '·ªµ': 'y.',
        '·∫≠': 'a\x5E.', '·ªá': 'e\x5E.', '·ªô': 'o\x5E.', '·ª±': 'u\x5E.',
        '·∫∑': 'a\x7E.', '·ª£': 'o\x7E.',
        
        // M≈© (circumflex)
        '√¢': 'a\x5E', '√™': 'e\x5E', '√¥': 'o\x5E', '√ª': 'u\x5E',
        '√Ç': 'A\x5E', '√ä': 'E\x5E', '√î': 'O\x5E', '√õ': 'U\x5E',
        
        // Breve - d√πng ~
        'ƒÉ': 'a~', 'ƒÇ': 'A~',
        
        // Horn - d√πng +
        '∆°': 'o+', '∆∞': 'u+', '∆†': 'O+', '∆Ø': 'U+',
        
        // ƒê ƒë
        'ƒë': 'd-', 'ƒê': 'D-'
      };

      let result = '';
      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        if (compositeMap[char]) {
          result += compositeMap[char];
        } else {
          result += char;
        }
      }
      
      return result;
    }
    function removeDiacritics(text) {
      const diacriticsMap = {
        // Ch·ªØ th∆∞·ªùng
        '√†': 'a', '√°': 'a', '·∫£': 'a', '√£': 'a', '·∫°': 'a',
        'ƒÉ': 'a', '·∫±': 'a', '·∫Ø': 'a', '·∫≥': 'a', '·∫µ': 'a', '·∫∑': 'a',
        '√¢': 'a', '·∫ß': 'a', '·∫•': 'a', '·∫©': 'a', '·∫´': 'a', '·∫≠': 'a',
        '√®': 'e', '√©': 'e', '·∫ª': 'e', '·∫Ω': 'e', '·∫π': 'e',
        '√™': 'e', '·ªÅ': 'e', '·∫ø': 'e', '·ªÉ': 'e', '·ªÖ': 'e', '·ªá': 'e',
        '√¨': 'i', '√≠': 'i', '·ªâ': 'i', 'ƒ©': 'i', '·ªã': 'i',
        '√≤': 'o', '√≥': 'o', '·ªè': 'o', '√µ': 'o', '·ªç': 'o',
        '√¥': 'o', '·ªì': 'o', '·ªë': 'o', '·ªï': 'o', '·ªó': 'o', '·ªô': 'o',
        '∆°': 'o', '·ªù': 'o', '·ªõ': 'o', '·ªü': 'o', '·ª°': 'o', '·ª£': 'o',
        '√π': 'u', '√∫': 'u', '·ªß': 'u', '≈©': 'u', '·ª•': 'u',
        '∆∞': 'u', '·ª´': 'u', '·ª©': 'u', '·ª≠': 'u', '·ªØ': 'u', '·ª±': 'u',
        '·ª≥': 'y', '√Ω': 'y', '·ª∑': 'y', '·ªπ': 'y', '·ªµ': 'y',
        'ƒë': 'd',
        
        // Ch·ªØ hoa
        '√Ä': 'A', '√Å': 'A', '·∫¢': 'A', '√É': 'A', '·∫†': 'A',
        'ƒÇ': 'A', '·∫∞': 'A', '·∫Æ': 'A', '·∫≤': 'A', '·∫¥': 'A', '·∫∂': 'A',
        '√Ç': 'A', '·∫¶': 'A', '·∫§': 'A', '·∫®': 'A', '·∫™': 'A', '·∫¨': 'A',
        '√à': 'E', '√â': 'E', '·∫∫': 'E', '·∫º': 'E', '·∫∏': 'E',
        '√ä': 'E', '·ªÄ': 'E', '·∫æ': 'E', '·ªÇ': 'E', '·ªÑ': 'E', '·ªÜ': 'E',
        '√å': 'I', '√ç': 'I', '·ªà': 'I', 'ƒ®': 'I', '·ªä': 'I',
        '√í': 'O', '√ì': 'O', '·ªé': 'O', '√ï': 'O', '·ªå': 'O',
        '√î': 'O', '·ªí': 'O', '·ªê': 'O', '·ªî': 'O', '·ªñ': 'O', '·ªò': 'O',
        '∆†': 'O', '·ªú': 'O', '·ªö': 'O', '·ªû': 'O', '·ª†': 'O', '·ª¢': 'O',
        '√ô': 'U', '√ö': 'U', '·ª¶': 'U', '≈®': 'U', '·ª§': 'U',
        '∆Ø': 'U', '·ª™': 'U', '·ª®': 'U', '·ª¨': 'U', '·ªÆ': 'U', '·ª∞': 'U',
        '·ª≤': 'Y', '√ù': 'Y', '·ª∂': 'Y', '·ª∏': 'Y', '·ª¥': 'Y',
        'ƒê': 'D'
      };

      return text.replace(/[√†√°·∫£√£·∫°ƒÉ·∫±·∫Ø·∫≥·∫µ·∫∑√¢·∫ß·∫•·∫©·∫´·∫≠√®√©·∫ª·∫Ω·∫π√™·ªÅ·∫ø·ªÉ·ªÖ·ªá√¨√≠·ªâƒ©·ªã√≤√≥·ªè√µ·ªç√¥·ªì·ªë·ªï·ªó·ªô∆°·ªù·ªõ·ªü·ª°·ª£√π√∫·ªß≈©·ª•∆∞·ª´·ª©·ª≠·ªØ·ª±·ª≥√Ω·ª∑·ªπ·ªµƒë√Ä√Å·∫¢√É·∫†ƒÇ·∫∞·∫Æ·∫≤·∫¥·∫∂√Ç·∫¶·∫§·∫®·∫™·∫¨√à√â·∫∫·∫º·∫∏√ä·ªÄ·∫æ·ªÇ·ªÑ·ªÜ√å√ç·ªàƒ®·ªä√í√ì·ªé√ï·ªå√î·ªí·ªê·ªî·ªñ·ªò∆†·ªú·ªö·ªû·ª†·ª¢√ô√ö·ª¶≈®·ª§∆Ø·ª™·ª®·ª¨·ªÆ·ª∞·ª≤√ù·ª∂·ª∏·ª¥ƒê]/g, 
        char => diacriticsMap[char] || char);
    }

    // Convert text to byte array - H·ªó tr·ª£ ti·∫øng Vi·ªát UTF-8
    function textToBytes(text) {
      // S·ª≠ d·ª•ng TextEncoder ƒë·ªÉ chuy·ªÉn UTF-8 th√†nh bytes ch√≠nh x√°c
      const encoder = new TextEncoder();
      const utf8Bytes = encoder.encode(text);
      
      // N·∫øu c√≥ k√Ω t·ª± ngo√†i ph·∫°m vi, fallback
      const result = [];
      for (let i = 0; i < utf8Bytes.length; i++) {
        result.push(utf8Bytes[i]);
      }
      
      return new Uint8Array(result);
    }

    // Wrap text to fit printer width
    function wrapText(text, maxLength) {
      if (text.length <= maxLength) return [text];
      
      const words = text.split(' ');
      const lines = [];
      let currentLine = '';
      
      for (const word of words) {
        if ((currentLine + word).length > maxLength && currentLine) {
          lines.push(currentLine.trim());
          currentLine = word + ' ';
        } else {
          currentLine += word + ' ';
        }
      }
      
      if (currentLine.trim()) {
        lines.push(currentLine.trim());
      }
      
      return lines;
    }

    // Format ng√†y theo chu·∫©n Vi·ªát Nam - gi·ªëng ·∫£nh th·ª±c t·∫ø
    function formatDateVietnam(date) {
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `Thang ${month}/${year}`;
    }

    // Format ti·ªÅn t·ªá Vi·ªát Nam - Adaptive cho t·∫•t c·∫£ encoding modes
    function formatMoneyVietnam(amount) {
      if (!amount || amount === 0) return '0 ƒë';
      
      const encodingMode = document.getElementById('encodingMode').value;
      
      // Image mode v√† other modes (tr·ª´ ascii) d√πng k√Ω t·ª± c√≥ d·∫•u
      const suffix = encodingMode === 'ascii-fallback' ? ' d' : ' ƒë';
      
      return new Intl.NumberFormat('vi-VN').format(amount) + suffix;
    }

    // Chuy·ªÉn s·ªë th√†nh ch·ªØ ti·∫øng Vi·ªát - Adaptive encoding cho t·∫•t c·∫£ modes
    function numberToVietnameseWords(num) {
      if (!num || num === 0) return 'Khong dong';
      
      const encodingMode = document.getElementById('encodingMode').value;
      
      if (encodingMode === 'ascii-fallback') {
        // ASCII safe version
        const ones = ['', 'mot', 'hai', 'ba', 'bon', 'nam', 'sau', 'bay', 'tam', 'chin'];
        const tens = ['', 'muoi', 'hai muoi', 'ba muoi', 'bon muoi', 'nam muoi', 
                     'sau muoi', 'bay muoi', 'tam muoi', 'chin muoi'];
        const scales = ['', 'ngan', 'trieu', 'ty'];
        
        function convertHundreds(n) {
          let result = '';
          
          if (n >= 100) {
            result += ones[Math.floor(n / 100)] + ' tram ';
            n %= 100;
          }
          
          if (n >= 20) {
            const tenDigit = Math.floor(n / 10);
            result += (tenDigit === 1 ? 'muoi' : ones[tenDigit] + ' muoi') + ' ';
            n %= 10;
          } else if (n >= 10) {
            result += 'muoi ';
            n %= 10;
          }
          
          if (n > 0) {
            if (n === 5 && result.includes('muoi')) {
              result += 'lam ';
            } else {
              result += ones[n] + ' ';
            }
          }
          
          return result;
        }
        
        let result = '';
        let scaleIndex = 0;
        
        while (num > 0) {
          const chunk = num % 1000;
          if (chunk !== 0) {
            const chunkText = convertHundreds(chunk);
            result = chunkText + scales[scaleIndex] + ' ' + result;
          }
          num = Math.floor(num / 1000);
          scaleIndex++;
        }
        
        result = result.trim().replace(/\s+/g, ' ');
        result = result.charAt(0).toUpperCase() + result.slice(1);
        
        return result + ' dong.';
        
      } else {
        // Vietnamese with diacritics version (cho image mode v√† encoding modes kh√°c)
        const ones = ['', 'm·ªôt', 'hai', 'ba', 'b·ªën', 'nƒÉm', 's√°u', 'b·∫£y', 't√°m', 'ch√≠n'];
        const tens = ['', 'm∆∞·ªùi', 'hai m∆∞·ªùi', 'ba m∆∞·ªùi', 'b·ªën m∆∞·ªùi', 'nƒÉm m∆∞·ªùi', 
                     's√°u m∆∞·ªùi', 'b·∫£y m∆∞·ªùi', 't√°m m∆∞·ªùi', 'ch√≠n m∆∞·ªùi'];
        const scales = ['', 'ngh√¨n', 'tri·ªáu', 't·ª∑'];
        
        function convertHundreds(n) {
          let result = '';
          
          if (n >= 100) {
            result += ones[Math.floor(n / 100)] + ' trƒÉm ';
            n %= 100;
          }
          
          if (n >= 20) {
            const tenDigit = Math.floor(n / 10);
            result += (tenDigit === 1 ? 'm∆∞·ªùi' : ones[tenDigit] + ' m∆∞·ªùi') + ' ';
            n %= 10;
          } else if (n >= 10) {
            result += 'm∆∞·ªùi ';
            n %= 10;
          }
          
          if (n > 0) {
            if (n === 5 && result.includes('m∆∞·ªùi')) {
              result += 'lƒÉm ';
            } else {
              result += ones[n] + ' ';
            }
          }
          
          return result;
        }
        
        let result = '';
        let scaleIndex = 0;
        
        while (num > 0) {
          const chunk = num % 1000;
          if (chunk !== 0) {
            const chunkText = convertHundreds(chunk);
            result = chunkText + scales[scaleIndex] + ' ' + result;
          }
          num = Math.floor(num / 1000);
          scaleIndex++;
        }
        
        result = result.trim().replace(/\s+/g, ' ');
        result = result.charAt(0).toUpperCase() + result.slice(1);
        
        return result + ' ƒë·ªìng.';
      }
    }

    function updateBluetoothStatus(connected, deviceName = '') {
      const status = document.getElementById('bluetoothStatus');
      const btn = document.getElementById('bluetoothBtn');
      
      if (connected) {
        status.innerHTML = `üü¢ ${deviceName || 'M√°y in'} ƒë√£ k·∫øt n·ªëi`;
        status.classList.add('connected');
        btn.innerHTML = '<span>üîå</span> Ng·∫Øt k·∫øt n·ªëi';
      } else {
        status.innerHTML = 'üî¥ Bluetooth ch∆∞a k·∫øt n·ªëi';
        status.classList.remove('connected');
        btn.innerHTML = '<span>üì∂</span> K·∫øt n·ªëi BT';
        bluetoothDevice = null;
        bluetoothCharacteristic = null;
      }
    }

    // ==================== GOOGLE SHEETS (unchanged) ====================
    
    async function testConnection() {
      const sheetId = document.getElementById('sheetId').value.trim();
      if (!sheetId) {
        alert('‚ùå Vui l√≤ng nh·∫≠p Sheet ID!');
        document.getElementById('sheetId').focus();
        return;
      }

      showStatus('loading', 'üîß Ki·ªÉm tra k·∫øt n·ªëi Google Sheets...');
      hideError();

      try {
        const data = await fetchSheetData();
        showStatus('success', `‚úÖ K·∫øt n·ªëi th√†nh c√¥ng! T√¨m th·∫•y ${data.length - 1} b·∫£n ghi`);
        setTimeout(() => loadData(), 1500);
      } catch (error) {
        showError(`‚ùå L·ªói k·∫øt n·ªëi Google Sheets: ${error.message}\n\nüí° Ki·ªÉm tra:\n‚Ä¢ Sheet ID c√≥ ƒë√∫ng kh√¥ng?\n‚Ä¢ Sheet c√≥ chia s·∫ª c√¥ng khai kh√¥ng?\n‚Ä¢ T√™n sheet c√≥ ƒë√∫ng kh√¥ng?`);
      }
    }

    async function fetchSheetData() {
      const sheetId = document.getElementById('sheetId').value.trim();
      const sheetName = document.getElementById('sheetName').value.trim() || 'Sheet1';
      
      const url = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(sheetName)}`;
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Accept': 'text/csv,application/csv',
        }
      });
      
      if (!response.ok) {
        if (response.status === 400) {
          throw new Error('Sheet ID kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng t·ªìn t·∫°i');
        } else if (response.status === 403) {
          throw new Error('Sheet ch∆∞a ƒë∆∞·ª£c chia s·∫ª c√¥ng khai. H√£y v√†o Google Sheets > Share > Anyone with link can view');
        } else {
          throw new Error(`HTTP ${response.status}: Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu`);
        }
      }
      
      const csvText = await response.text();
      
      if (!csvText || csvText.trim() === '') {
        throw new Error('Sheet tr·ªëng ho·∫∑c t√™n sheet kh√¥ng ƒë√∫ng');
      }
      
      return parseCSV(csvText);
    }

    function parseCSV(csvText) {
      const lines = csvText.split('\n').filter(line => line.trim());
      return lines.map(line => {
        const values = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          if (char === '"') {
            if (inQuotes && line[i + 1] === '"') {
              current += '"';
              i++;
            } else {
              inQuotes = !inQuotes;
            }
          } else if (char === ',' && !inQuotes) {
            values.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        values.push(current.trim());
        return values;
      });
    }

    async function loadData() {
      showStatus('loading', 'üìä ƒêang t·∫£i d·ªØ li·ªáu t·ª´ Google Sheets...');
      hideError();

      try {
        const data = await fetchSheetData();
        if (data.length === 0) {
          showStatus('error', 'üì≠ Sheet tr·ªëng ho·∫∑c kh√¥ng c√≥ d·ªØ li·ªáu');
          return;
        }

        const headers = data[0];
        const rows = data.slice(1).filter(row => 
          row.some(cell => cell && cell.toString().trim() !== '')
        );
        
        allRecords = rows.map((row, index) => ({
          rowIndex: index + 2,
          data: row,
          headers: headers
        }));

        displayRecords();
        showStatus('success', `üìÑ ƒê√£ t·∫£i th√†nh c√¥ng ${allRecords.length} b·∫£n ghi`);

      } catch (error) {
        showError(`‚ùå L·ªói t·∫£i d·ªØ li·ªáu: ${error.message}`);
      }
    }

    function displayRecords() {
      const container = document.getElementById('records');
      const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();
      
      let filteredRecords = allRecords;
      if (searchTerm) {
        filteredRecords = allRecords.filter(record => 
          record.data.some(cell => 
            cell && cell.toString().toLowerCase().includes(searchTerm)
          )
        );
      }

      if (filteredRecords.length === 0) {
        container.innerHTML = '<div class="status">üì≠ Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu ph√π h·ª£p</div>';
        return;
      }

      container.innerHTML = filteredRecords.map(record => {
        const row = record.data;
        const headers = record.headers;
        
        const nameIdx = findColumnIndex(headers, ['t√™n', 'kh√°ch h√†ng', 'name']);
        const addressIdx = findColumnIndex(headers, ['ƒë·ªãa ch·ªâ', 'address', 'diachi']);
        const phoneIdx = findColumnIndex(headers, ['ƒëi·ªán tho·∫°i', 'phone', 'sdt', 'dienthoai', 'li√™n h·ªá']);
        const serviceIdx = findColumnIndex(headers, ['thu√™ bao', 'service', 'thuebao', 'd·ªãch v·ª•']);
        const contentIdx = findColumnIndex(headers, ['n·ªôi dung', 'content', 'noidung', 'ghi ch√∫', 'ghichu']);
        const amountIdx = findColumnIndex(headers, ['ti·ªÅn', 's·ªë ti·ªÅn', 'sotien', 'amount', 'money', 'th√†nh ti·ªÅn']);
        const printedIdx = findColumnIndex(headers, ['ƒë√£ in', 'printed', 'dain', 'status']);
        const invoiceIdx = findColumnIndex(headers, ['m√£', 'h√≥a ƒë∆°n', 'invoice', 'id', 'mahd']);
        
        const name = row[nameIdx] || 'N/A';
        const address = row[addressIdx] || 'N/A';
        const phone = row[phoneIdx] || 'N/A';
        const service = row[serviceIdx] || 'N/A';
        const content = row[contentIdx] || 'Thu ti·ªÅn internet';
        const amount = parseFloat((row[amountIdx] || '0').toString().replace(/[^\d.-]/g, '')) || 0;
        const printed = (row[printedIdx] || '').toString().toLowerCase().includes('ƒë√£ in');
        const invoice = row[invoiceIdx] || '';
        
        return `
          <div class="record ${printed ? 'printed' : ''}">
            <div class="record-info">
              <div class="record-name">
                üë§ ${name}
                ${printed ? '<span style="color: #27ae60; font-size: 20px;">‚úÖ</span>' : ''}
              </div>
              <div class="record-details">
                <div><strong>üìç ƒê·ªãa ch·ªâ:</strong> ${address}</div>
                <div><strong>üìû ƒêi·ªán tho·∫°i:</strong> ${phone}</div>
                <div><strong>üì° Thu√™ bao:</strong> ${service}</div>
                <div><strong>üìù N·ªôi dung:</strong> ${content}</div>
                ${invoice ? `<div><strong>üè∑Ô∏è M√£ Hƒê:</strong> ${invoice}</div>` : ''}
              </div>
            </div>
            <div class="record-actions">
              <div class="amount">üí∞ ${formatMoney(amount)}</div>
              ${printed ? 
                '<div class="print-status">‚úÖ ƒê√£ in r·ªìi</div>' : 
                `<button class="btn btn-danger" onclick="printReceipt('${escapeQuotes(name)}', '${escapeQuotes(address)}', '${phone}', '${escapeQuotes(service)}', '${escapeQuotes(content)}', ${amount}, '${invoice}', ${record.rowIndex})">
                  <span>üñ®Ô∏è</span> In Phi·∫øu
                </button>`
              }
            </div>
          </div>
        `;
      }).join('');
    }

    function findColumnIndex(headers, possibleNames) {
      for (const name of possibleNames) {
        const index = headers.findIndex(header => 
          header && header.toLowerCase().includes(name.toLowerCase())
        );
        if (index !== -1) return index;
      }
      return -1;
    }

    function escapeQuotes(str) {
      return str.replace(/'/g, "\\'").replace(/"/g, '\\"');
    }

    async function printReceipt(name, address, phone, service, content, amount, invoice, rowIndex) {
      if (!bluetoothCharacteristic) {
        if (confirm('‚ùå Ch∆∞a k·∫øt n·ªëi m√°y in Y58!\n\nüì∂ B·∫°n c√≥ mu·ªën k·∫øt n·ªëi ngay kh√¥ng?')) {
          await connectBluetooth();
          if (!bluetoothCharacteristic) return;
        } else {
          return;
        }
      }

      try {
        const encodingMode = document.getElementById('encodingMode').value;
        
        if (encodingMode === 'image-render') {
          showStatus('loading', 'üñºÔ∏è ƒêang render phi·∫øu th√†nh ·∫£nh v√† in...');
        } else {
          showStatus('loading', `üñ®Ô∏è ƒêang in phi·∫øu thu (${encodingMode})...`);
        }

        await printReceiptBluetooth({
          name, address, phone, service, content, amount, invoice
        });

        if (encodingMode === 'image-render') {
          showStatus('success', `‚úÖ ƒê√£ in th√†nh c√¥ng phi·∫øu ·∫£nh c·ªßa ${name}!`);
        } else {
          showStatus('success', `‚úÖ ƒê√£ in th√†nh c√¥ng phi·∫øu c·ªßa ${name}!`);
        }

      } catch (error) {
        console.error('Print error:', error);
        showError(`‚ùå L·ªói in phi·∫øu: ${error.message}`);
      }
    }

    // ==================== HELPER FUNCTIONS ====================

    function search() {
      if (allRecords.length === 0) {
        alert('‚ö†Ô∏è Ch∆∞a t·∫£i d·ªØ li·ªáu. H√£y nh·∫•n "Test Sheet" tr∆∞·ªõc!');
        return;
      }
      displayRecords();
    }

    function loadAll() {
      document.getElementById('searchInput').value = '';
      if (allRecords.length === 0) {
        loadData();
      } else {
        displayRecords();
      }
    }

    function formatMoney(amount) {
      if (!amount || amount === 0) return '0 ƒë';
      return new Intl.NumberFormat('vi-VN', {
        style: 'currency', 
        currency: 'VND'
      }).format(amount).replace('‚Ç´', 'ƒë');
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function showStatus(type, message) {
      const status = document.getElementById('status');
      status.className = `status ${type}`;
      status.textContent = message;
      status.style.display = 'block';
    }

    function showError(message) {
      const error = document.getElementById('error');
      error.textContent = message;
      error.style.display = 'block';
      document.getElementById('status').style.display = 'none';
    }

    function hideError() {
      document.getElementById('error').style.display = 'none';
    }
  </script>
</body>
</html>
